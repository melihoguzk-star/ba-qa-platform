"""
Settings Page - API Key Management & Configuration
"""
import streamlit as st
from utils.config import get_gemini_keys
from utils.key_manager import APIKeyManager
from datetime import datetime
import hashlib
import os
from pathlib import Path
from components.sidebar import render_custom_sidebar

st.set_page_config(page_title="Settings", page_icon="âš™ï¸", layout="wide")
render_custom_sidebar(active_page="ayarlar")

# Initialize session state for keys
if "gemini_keys" not in st.session_state:
    st.session_state.gemini_keys = get_gemini_keys()

# Initialize Anthropic key from secrets if not in session
if "anthropic_key" not in st.session_state:
    try:
        if "ANTHROPIC_API_KEY" in st.secrets:
            st.session_state.anthropic_key = st.secrets["ANTHROPIC_API_KEY"]
        else:
            st.session_state.anthropic_key = ""
    except:
        st.session_state.anthropic_key = ""

if "key_manager" not in st.session_state:
    if st.session_state.gemini_keys:
        st.session_state.key_manager = APIKeyManager(st.session_state.gemini_keys, provider="gemini")
    else:
        st.session_state.key_manager = None


def mask_key(key: str) -> str:
    """Mask API key for display"""
    if len(key) < 12:
        return f"{key[:4]}***{key[-4:]}"
    return f"{key[:8]}***{key[-4:]}"


def hash_key(key: str) -> str:
    """Create short hash of key"""
    return hashlib.sha256(key.encode()).hexdigest()[:8]


def test_gemini_key(key: str) -> tuple[bool, str]:
    """Test if Gemini API key is valid"""
    try:
        from google import genai
        client = genai.Client(api_key=key)
        # Simple test call
        response = client.models.generate_content(
            model="gemini-2.5-flash",
            contents="Say 'OK' if you can read this.",
            config=genai.types.GenerateContentConfig(
                max_output_tokens=10,
                temperature=0.0,
            ),
        )
        if response.text:
            return True, "âœ… Key is valid"
        return False, "âŒ No response from API"
    except Exception as e:
        error_msg = str(e)
        if "api key not valid" in error_msg.lower() or "invalid" in error_msg.lower():
            return False, "âŒ Invalid API key"
        elif "quota" in error_msg.lower():
            return True, "âš ï¸ Key valid but quota exceeded"
        else:
            return False, f"âŒ Error: {error_msg[:100]}"


def save_keys_to_secrets():
    """Save API keys to .streamlit/secrets.toml file"""
    try:
        secrets_dir = Path(".streamlit")
        secrets_file = secrets_dir / "secrets.toml"
        
        # Create .streamlit directory if it doesn't exist
        secrets_dir.mkdir(exist_ok=True)
        
        # Build TOML content
        toml_content = "# API Keys Configuration\n"
        toml_content += "# Auto-generated by BA&QA Platform Settings\n\n"
        
        # Gemini keys
        if st.session_state.gemini_keys:
            if len(st.session_state.gemini_keys) == 1:
                # Single key format (backward compatible)
                toml_content += f'GEMINI_API_KEY = "{st.session_state.gemini_keys[0]}"\n'
            else:
                # Multiple keys format
                toml_content += "GEMINI_API_KEYS = [\n"
                for key in st.session_state.gemini_keys:
                    toml_content += f'    "{key}",\n'
                toml_content += "]\n"
        
        toml_content += "\n"
        
        # Anthropic key
        if st.session_state.get("anthropic_key"):
            toml_content += f'ANTHROPIC_API_KEY = "{st.session_state.anthropic_key}"\n'
        
        # Write to file
        with open(secrets_file, "w") as f:
            f.write(toml_content)
        
        return True, f"âœ… Keys saved to {secrets_file}"
    except Exception as e:
        return False, f"âŒ Error saving keys: {str(e)}"


# Header
st.title("âš™ï¸ Settings")
st.markdown("Manage API keys, rotation settings, and view usage statistics.")

# Tabs
tab1, tab2, tab3, tab4 = st.tabs(["ğŸ”‘ API Keys", "âš™ï¸ Rotation Settings", "ğŸ“Š Statistics", "ğŸ” Vector Store"])

# ============================================================================
# TAB 1: API KEYS MANAGEMENT
# ============================================================================
with tab1:
    st.header("ğŸ”‘ API Key Management")
    
    # Gemini Keys Section (Read-Only)
    st.subheader("ğŸ”‘ Gemini API Keys")
    st.info("ğŸ’¡ **To add/remove keys:** Edit `.streamlit/secrets.toml` file and restart Streamlit.")
    
    if st.session_state.gemini_keys:
        st.success(f"âœ… **{len(st.session_state.gemini_keys)} key(s) configured**")
        
        for idx, key in enumerate(st.session_state.gemini_keys, 1):
            with st.expander(f"Key {idx}: {mask_key(key)}", expanded=False):
                col1, col2 = st.columns([3, 1])
                
                with col1:
                    st.code(mask_key(key), language="text")
                    st.caption(f"Hash: {hash_key(key)}")
                    
                    # Show status if key manager exists
                    if st.session_state.key_manager:
                        key_hash = hash_key(key)
                        stats = st.session_state.key_manager.usage_stats.get(key_hash, {})
                        status = stats.get("status", "unknown")
                        requests = stats.get("requests", 0)
                        
                        if status == "active":
                            st.caption(f"âœ… Active ({requests} requests)")
                        elif status == "quota_exceeded":
                            st.caption(f"âš ï¸ Quota Exceeded ({requests} requests)")
                        elif status == "invalid":
                            st.caption(f"âŒ Invalid")
                
                with col2:
                    if st.button("ğŸ§ª Test", key=f"test_{idx}", use_container_width=True):
                        with st.spinner("Testing..."):
                            is_valid, message = test_gemini_key(key)
                            if is_valid:
                                st.success(message)
                            else:
                                st.error(message)
    else:
        st.warning("âš ï¸ **No Gemini keys configured**")
        st.markdown("""
        **To add keys:**
        1. Open `.streamlit/secrets.toml`
        2. Add single key:
           ```toml
           GEMINI_API_KEY = "your-key-here"
           ```
        3. Or multiple keys:
           ```toml
           GEMINI_API_KEYS = [
               "key-1",
               "key-2",
               "key-3"
           ]
           ```
        4. Restart Streamlit
        """)
    
    st.divider()
    
    
    # Anthropic Key Section
    st.subheader("Anthropic API Key (Claude)")
    
    anthropic_key = st.session_state.get("anthropic_key", "")
    
    if anthropic_key:
        st.text(f"Key: {mask_key(anthropic_key)}")
        st.caption("âœ… Configured")
        if st.button("ğŸ—‘ï¸ Remove Anthropic Key"):
            del st.session_state["anthropic_key"]
            st.rerun()
    else:
        st.info("â„¹ï¸ No Anthropic key configured. Add one to use Claude models.")
        
        with st.form("add_anthropic_key"):
            new_anthropic_key = st.text_input(
                "Anthropic API Key",
                type="password",
                placeholder="sk-ant-...",
                help="Enter your Anthropic API key"
            )
            
            if st.form_submit_button("â• Add Anthropic Key", use_container_width=True):
                if new_anthropic_key:
                    st.session_state.anthropic_key = new_anthropic_key
                    st.toast("âœ… Anthropic key added!", icon="âœ…")
                    st.success("âœ… Anthropic key added!")
                    st.rerun()

# ============================================================================
# TAB 2: ROTATION SETTINGS
# ============================================================================
with tab2:
    st.header("âš™ï¸ Rotation Settings")
    
    if not st.session_state.gemini_keys or len(st.session_state.gemini_keys) < 2:
        st.warning("âš ï¸ Add at least 2 Gemini keys to enable rotation.")
    else:
        st.success(f"âœ… Rotation enabled with {len(st.session_state.gemini_keys)} keys")
    
    st.subheader("Rotation Strategy")
    
    rotation_strategy = st.radio(
        "Select rotation strategy:",
        ["Least Used", "Round Robin", "Random"],
        index=0,
        help="Least Used: Selects the key with fewest requests (default)"
    )
    
    st.info(f"â„¹ï¸ Current strategy: **{rotation_strategy}**")
    
    st.divider()
    
    st.subheader("Auto-Reset Settings")
    
    auto_reset = st.checkbox(
        "Enable daily quota reset",
        value=True,
        help="Automatically reset quota status at 00:00 UTC"
    )
    
    if auto_reset:
        st.success("âœ… Keys will be reset daily at 00:00 UTC")
    
    st.divider()
    
    st.subheader("Manual Actions")
    
    col1, col2 = st.columns(2)
    
    with col1:
        if st.button("ğŸ”„ Reset All Keys Now", use_container_width=True):
            if st.session_state.key_manager:
                st.session_state.key_manager.reset_all_keys()
                st.success("âœ… All keys reset successfully!")
                st.rerun()
    
    with col2:
        if st.button("ğŸ“Š Refresh Statistics", use_container_width=True):
            st.rerun()

# ============================================================================
# TAB 3: STATISTICS
# ============================================================================
with tab3:
    st.header("ğŸ“Š Usage Statistics")
    
    if not st.session_state.key_manager:
        st.info("â„¹ï¸ No statistics available. Add Gemini keys to start tracking.")
    else:
        stats = st.session_state.key_manager.get_stats()
        
        # Overview metrics
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("Total Keys", stats["total_keys"])
        with col2:
            st.metric("Active Keys", stats["active_keys"], 
                     delta=None if stats["active_keys"] == stats["total_keys"] else f"-{stats['failed_keys']}")
        with col3:
            st.metric("Total Requests", stats["total_requests"])
        with col4:
            st.metric("Total Errors", stats["total_errors"])
        
        st.divider()
        
        # Per-key statistics
        st.subheader("Per-Key Statistics")
        
        if stats["keys"]:
            for key_stat in stats["keys"]:
                with st.expander(f"ğŸ”‘ {key_stat['key_preview']}", expanded=False):
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        st.metric("Status", key_stat["status"].replace("_", " ").title())
                        st.metric("Requests", key_stat["requests"])
                    
                    with col2:
                        st.metric("Errors", key_stat["errors"])
                        if key_stat["last_used"]:
                            st.caption(f"Last used: {key_stat['last_used']}")
                    
                    if key_stat["last_error"]:
                        st.error(f"Last error: {key_stat['last_error'][:100]}")
        else:
            st.info("â„¹ï¸ No usage data yet. Keys will appear here after first use.")
        
        st.divider()
        
        # Key distribution chart (if we have data)
        if stats["total_requests"] > 0:
            st.subheader("Request Distribution")
            
            chart_data = {
                key_stat["key_preview"]: key_stat["requests"] 
                for key_stat in stats["keys"]
            }
            
            st.bar_chart(chart_data)

    # Smart Matching Analytics (Phase 2C)
    st.divider()
    st.subheader("ğŸ” Smart Matching Analytics")

    try:
        from data.database import get_task_match_analytics

        # Time range selector
        match_time_range = st.selectbox(
            "Time Range",
            ["7days", "30days", "90days", "all"],
            format_func=lambda x: {
                "7days": "Last 7 Days",
                "30days": "Last 30 Days",
                "90days": "Last 90 Days",
                "all": "All Time"
            }[x],
            key="match_analytics_time_range"
        )

        analytics = get_task_match_analytics(match_time_range)

        # Overview metrics
        col1, col2, col3, col4 = st.columns(4)

        with col1:
            st.metric("Total Matches", analytics["total_matches"])
        with col2:
            st.metric("Accepted", analytics["total_accepted"])
        with col3:
            st.metric("Acceptance Rate", f"{analytics['acceptance_rate']:.1f}%")
        with col4:
            st.metric("Avg Confidence", f"{analytics['avg_confidence']:.2f}")

        # Suggestion breakdown
        if analytics["suggestion_breakdown"]:
            st.markdown("**Suggestion Breakdown**")
            col1, col2 = st.columns(2)

            with col1:
                for item in analytics["suggestion_breakdown"]:
                    suggestion = item["suggestion"] or "N/A"
                    count = item["count"]
                    accepted = item["accepted"] or 0
                    rate = (accepted / count * 100) if count > 0 else 0
                    st.caption(f"**{suggestion}:** {count} matches ({rate:.0f}% accepted)")

            with col2:
                # Document type breakdown
                if analytics["doc_type_breakdown"]:
                    st.markdown("**Document Type Breakdown**")
                    for item in analytics["doc_type_breakdown"]:
                        doc_type = item["doc_type"] or "N/A"
                        count = item["count"]
                        avg_conf = item["avg_confidence"] or 0.0
                        st.caption(f"**{doc_type.upper()}:** {count} matches (avg: {avg_conf:.2f})")
        else:
            st.info("â„¹ï¸ No smart matching data yet. Use the Smart Matching feature to start tracking.")

    except ImportError:
        st.warning("âš ï¸ Smart Matching module not available.")
    except Exception as e:
        st.error(f"âŒ Error loading smart matching analytics: {str(e)}")

# ============================================================================
# TAB 4: VECTOR STORE (Phase 2B)
# ============================================================================
with tab4:
    st.header("ğŸ” Vector Store Status")
    st.markdown("Monitor semantic search infrastructure and ChromaDB collections.")

    try:
        from pipeline.vector_store import get_vector_store
        import os

        # Check if semantic search is enabled
        semantic_enabled = os.getenv('ENABLE_SEMANTIC_SEARCH', 'true').lower() == 'true'
        auto_indexing = os.getenv('ENABLE_AUTO_INDEXING', 'true').lower() == 'true'

        # Feature status
        st.subheader("âš™ï¸ Configuration")
        col1, col2 = st.columns(2)

        with col1:
            if semantic_enabled:
                st.success("âœ… Semantic Search: Enabled")
            else:
                st.warning("âš ï¸ Semantic Search: Disabled")

        with col2:
            if auto_indexing:
                st.success("âœ… Auto-Indexing: Enabled")
            else:
                st.warning("âš ï¸ Auto-Indexing: Disabled")

        st.divider()

        # Get vector store stats
        with st.spinner("Loading vector store statistics..."):
            vector_store = get_vector_store()
            stats = vector_store.get_collection_stats()

        # Collection statistics
        st.subheader("ğŸ“Š Collection Statistics")

        col1, col2, col3 = st.columns(3)

        with col1:
            ba_stats = stats.get('ba', {})
            chunk_count = ba_stats.get('chunk_count', 0)
            status = ba_stats.get('status', 'unknown')
            status_icon = 'âœ…' if status == 'active' else 'âŒ'

            st.metric(
                "BA Documents",
                f"{chunk_count} chunks",
                help="Business Analysis document chunks indexed"
            )
            st.caption(f"{status_icon} {status.title()}")

        with col2:
            ta_stats = stats.get('ta', {})
            chunk_count = ta_stats.get('chunk_count', 0)
            status = ta_stats.get('status', 'unknown')
            status_icon = 'âœ…' if status == 'active' else 'âŒ'

            st.metric(
                "TA Documents",
                f"{chunk_count} chunks",
                help="Technical Analysis document chunks indexed"
            )
            st.caption(f"{status_icon} {status.title()}")

        with col3:
            tc_stats = stats.get('tc', {})
            chunk_count = tc_stats.get('chunk_count', 0)
            status = tc_stats.get('status', 'unknown')
            status_icon = 'âœ…' if status == 'active' else 'âŒ'

            st.metric(
                "TC Documents",
                f"{chunk_count} chunks",
                help="Test Case document chunks indexed"
            )
            st.caption(f"{status_icon} {status.title()}")

        # Total chunks
        total_chunks = sum(s.get('chunk_count', 0) for s in stats.values())
        st.info(f"ğŸ“¦ **Total indexed chunks:** {total_chunks}")

        st.divider()

        # Model information
        st.subheader("ğŸ¤– Embedding Model")

        model_name = os.getenv('EMBEDDING_MODEL', 'intfloat/multilingual-e5-base')
        st.code(model_name, language="text")
        st.caption("Multilingual support: Turkish + English")

        st.divider()

        # Test semantic search
        st.subheader("ğŸ§ª Test Semantic Search")

        with st.form("test_semantic_search"):
            test_query = st.text_input(
                "Enter test query",
                placeholder="kullanÄ±cÄ± giriÅŸ ekranÄ±",
                help="Test semantic search with a sample query"
            )

            test_doc_type = st.selectbox(
                "Document type",
                options=['ba', 'ta', 'tc'],
                format_func=lambda x: {'ba': 'Business Analysis', 'ta': 'Technical Analysis', 'tc': 'Test Cases'}[x]
            )

            if st.form_submit_button("ğŸ” Search", use_container_width=True):
                if test_query:
                    with st.spinner(f"Searching {test_doc_type} documents..."):
                        try:
                            results = vector_store.search(
                                query_text=test_query,
                                doc_type=test_doc_type,
                                top_k=5
                            )

                            if results:
                                st.success(f"âœ… Found {len(results)} results!")

                                for i, result in enumerate(results, 1):
                                    with st.expander(f"{i}. Document {result['document_id']} - Similarity: {result['similarity']:.1%}"):
                                        st.write(f"**Matched Chunk:**")
                                        st.text(result['chunk_text'][:200] + "..." if len(result['chunk_text']) > 200 else result['chunk_text'])

                                        metadata = result.get('metadata', {})
                                        st.caption(f"Chunk Type: {metadata.get('chunk_type', 'unknown')}")
                            else:
                                st.warning("No results found. Try a different query.")

                        except Exception as e:
                            st.error(f"âŒ Search failed: {str(e)}")
                else:
                    st.warning("Please enter a query.")

        st.divider()

        # ChromaDB location
        st.subheader("ğŸ’¾ Storage")
        st.code(vector_store.persist_directory, language="bash")
        st.caption("ChromaDB persistent storage location")

    except ImportError:
        st.error("âŒ Vector Store module not available. Make sure Phase 2A is installed.")
        st.code("pip install chromadb sentence-transformers torch", language="bash")

    except Exception as e:
        st.error(f"âŒ Error loading vector store: {str(e)}")
        st.info("ğŸ’¡ Make sure you're using Python 3.12 (not 3.14) for ChromaDB compatibility.")

# Footer
st.divider()
st.caption("ğŸ’¡ Tip: Add multiple Gemini keys to increase your daily quota and enable automatic rotation.")
